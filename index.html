<!DOCTYPE html>
<html>
<head>
	<title>SightReader</title>
	<link rel="stylesheet" href="http://code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css"/>
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.9.1.js"></script>
    <script type="text/javascript" src="http://code.jquery.com/ui/1.10.3/jquery-ui.js"></script>
	<!-- <script type="text/javascript" src="/static/opensheetmusicdisplay.min.js"></script> -->
	<!-- <script src="https://eabiao.github.io/static/opensheetmusicdisplay.min.js"></script> -->
	<!--  <script type="text/javascript" src="/static/jquery-1.10.2.min.js"></script>
	<script type="text/javascript" src="/static/jquery.alphaTab.js"></script> 
	 
	
	 <script type="text/javascript" src="/static/alphaTab.core.js"></script> -->

	 <!-- <script type="text/javascript" src="/node_modules/vexflow/releases/vexflow-min.js"></script> -->

	 <script type="text/javascript" src="/static/osmd.js"></script>

	 <script type="text/javascript" src="/static/vexflow-debug.js"></script>

	 <link rel="stylesheet" href="/static/style.css"/>

</head>
<body>

Hello from index.html


<div id="vexflow-id"></div>

<script type="text/javascript">
	VF = Vex.Flow;

// We created an object to store the information about the workspace
var WorkspaceInformation = {
    // The div in which you're going to work
    div: document.getElementById("vexflow-id"),
    // Vex creates a svg with specific dimensions
    canvasWidth: 500,
    canvasHeight: 500
};

// Create a renderer with SVG
var renderer = new VF.Renderer(
    WorkspaceInformation.div,
    VF.Renderer.Backends.SVG
);

// Use the renderer to give the dimensions to the SVG
renderer.resize(WorkspaceInformation.canvasWidth, WorkspaceInformation.canvasHeight);

// Expose the context of the renderer
var context = renderer.getContext();

// And give some style to our SVG
context.setFont("Arial", 10, "").setBackgroundFillStyle("#eed");


/**
 * Creating a new stave
 */
// Create a stave of width 400 at position x10, y40 on the SVG.
var stave = new VF.Stave(10, 40, 400);
// Add a clef and time signature.
stave.addClef("treble").addTimeSignature("4/4");
// Set the context of the stave our previous exposed context and execute the method draw !
stave.setContext(context).draw();

var notes = [
  // A quarter-note C.
  new VF.StaveNote({clef: "treble", keys: ["c/4"], duration: "q" }),

  // A quarter-note D.
  new VF.StaveNote({clef: "treble", keys: ["d/4"], duration: "q" }),

  // A quarter-note rest. Note that the key (b/4) specifies the vertical
  // position of the rest.
  new VF.StaveNote({clef: "treble", keys: ["b/4"], duration: "qr" }),

  // A C-Major chord.
  new VF.StaveNote({clef: "treble", keys: ["c/4", "e/4", "g/4"], duration: "q" })
];

// Create a voice in 4/4 and add above notes
var voice = new VF.Voice({num_beats: 4,  beat_value: 4});
voice.addTickables(notes);

// Format and justify the notes to 400 pixels.
var formatter = new VF.Formatter().joinVoices([voice]).format([voice], 400);

// Render voice
voice.draw(context, stave);

</script>



<div id="osmdCanvas"/>

<script>
    var container = document.getElementById("osmdCanvas");
    var osmd = new OpenSheetMusicDisplay(container);

    var musicXMLString = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
    <!DOCTYPE score-partwise PUBLIC
        "-//Recordare//DTD MusicXML 3.1 Partwise//EN"
        "http://www.musicxml.org/dtds/partwise.dtd">
    <score-partwise version="3.1">
      <part-list>
        <score-part id="P1">
          <part-name>Music</part-name>
        </score-part>
      </part-list>
      <part id="P1">
        <measure number="1">
          <attributes>
            <divisions>1</divisions>
            <key>
              <fifths>0</fifths>
            </key>
            <time>
              <beats>4</beats>
              <beat-type>4</beat-type>
            </time>
            <clef>
              <sign>G</sign>
              <line>2</line>
            </clef>
          </attributes>
          <note>
            <pitch>
              <step>C</step>
              <octave>4</octave>
            </pitch>
            <duration>4</duration>
            <type>whole</type>
          </note>
        </measure>
      </part>
    </score-partwise>`;

    $("#test").text(musicXMLString);

    osmd.load(musicXMLString);
    container.style.width = "720px";
    osmd.render();
</script>

After Script


<div id="container">
  <div id="boo"></div>
</div>
<div id="controls">
  <button id='start-btn'>Start</button>
  <button id='right-answer'>Right Answer</button>
</div>

<script type="text/javascript">
	
// Basic setup boilerplate for using VexFlow with the SVG rendering context:
VF = Vex.Flow;

// Create an SVG renderer and attach it to the DIV element named "boo".
var div = document.getElementById("boo")
var renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);

// Configure the rendering context.
renderer.resize(500, 500);
var context = renderer.getContext();

// A tickContext is required to draw anything that would be placed
// in relation to time/rhythm, including StaveNote which we use here.
// In real music, this allows VexFlow to align notes from multiple
// voices with different rhythms horizontally. Here, it doesn't do much
// for us, since we'll be animating the horizontal placement of notes, 
// but we still need to add our notes to a tickContext so that they get
// an x value and can be rendered.
//
// If we create a voice, it will automatically apply a tickContext to our
// notes, and space them relative to each other based on their duration &
// the space available. We definitely do not want that here! So, instead
// of creating a voice, we handle that part of the drawing manually.
var tickContext = new VF.TickContext();

// Create a stave of width 10000 at position 10, 40 on the canvas.
var stave = new VF.Stave(10, 10, 10000)
.addClef('treble');

// Connect it to the rendering context and draw!
stave.setContext(context).draw();

var durations = ['8', '4', '2', '1'];

var notes = [
	['c', '#', '4'],
	['e', 'b', '5'],
	['g', '', '5'],
	['d', 'b', '4'],
	['b', 'bb', '3'],
	['a', 'b', '4'],
	['f', 'b', '5'],
].map(([letter, acc, octave]) => {
	const note = new VF.StaveNote({
    clef: 'treble',
    keys: [`${letter}${acc}/${octave}`],
    duration: durations[Math.floor(Math.random()*durations.length)],
  })
  .setContext(context)
  .setStave(stave);

  // If a StaveNote has an accidental, we must render it manually.
  // This is so that you get full control over whether to render
  // an accidental depending on the musical context. Here, if we
  // have one, we want to render it. (Theoretically, we might
  // add logic to render a natural sign if we had the same letter
  // name previously with an accidental. Or, perhaps every twelfth
  // note or so we might render a natural sign randomly, just to be
  // sure our user who's learning to read accidentals learns
  // what the natural symbol means.)
  if(acc) note.addAccidental(0, new VF.Accidental(acc));
	tickContext.addTickable(note)
	return note;
});

// The tickContext.preFormat() call assigns x-values (and other
// formatting values) to notes. It must be called after we've 
// created the notes and added them to the tickContext. Or, it
// can be called each time a note is added, if the number of 
// notes needed is not known at the time of bootstrapping.
//
// To see what happens if you put it in the wrong place, try moving
// this line up to where the TickContext is initialized, and check
// out the error message you get.
//
// tickContext.setX() establishes the left-most x position for all
// of the 'tickables' (notes, etc...) in a context.
tickContext.preFormat().setX(400);

// This will contain any notes that are currently visible on the staff,
// before they've either been answered correctly, or plumetted off
// the staff when a user fails to answer them correctly in time.
// TODO: Add sound effects.
const visibleNoteGroups = [];

note_values = ['a','b','c','d','e','f','g']
accidental_values = ['', '#', 'b', 'bb',]
octaves = ['4','5']

// Add a note to the staff from the notes array (if there are any left).
document.getElementById('start-btn').addEventListener('click', (e) => {

	setInterval(function(){ 

		var letter = note_values[Math.floor(Math.random()*note_values.length)];
	var accidental = accidental_values[Math.floor(Math.random()*accidental_values.length)];
	var octave = octaves[Math.floor(Math.random()*octaves.length)];

	console.log(letter, accidental,octave);

 	var note = new VF.StaveNote({
 		clef: "treble", keys: [letter+accidental+'/'+octave], duration: "4" 
 	});
      
      if (accidental != "") {
      	note.addAccidental(0, new VF.Accidental(accidental))
      }

      note.setContext(context).setStave(stave);

      tickContext.addTickable(note)

      console.log(note);
	tickContext.preFormat().setX(400);
	// note = notes.shift();
	// if(!note) return;
  const group = context.openGroup();
  visibleNoteGroups.push(group);
	note.draw();
  context.closeGroup();
	group.classList.add('scroll');
	// Force a dom-refresh by asking for the group's bounding box. Why? Most
  // modern browsers are smart enough to realize that adding .scroll class
  // hasn't changed anything about the rendering, so they wait to apply it
  // at the next dom refresh, when they can apply any other changes at the
  // same time for optimization. However, if we allow that to happen,
  // then sometimes the note will immediately jump to its fully transformed
  // position -- because the transform will be applied before the class with
  // its transition rule. 
  const box = group.getBoundingClientRect();
	group.classList.add('scrolling');

	// If a user doesn't answer in time make the note fall below the staff
	window.setTimeout(() => {
		const index = visibleNoteGroups.indexOf(group);
		if(index === -1) return;
		group.classList.add('too-slow');
    visibleNoteGroups.shift();
	}, 5000); // 5000 is the time 


	}, 2000);

});

// If a user plays/identifies the note in time, send it up to note heaven.
document.getElementById('right-answer').addEventListener('click', (e) => {
	group = visibleNoteGroups.shift();
  group.classList.add('correct');
	// The note will be somewhere in the middle of its move to the left -- by
  // getting its computed style we find its x-position, freeze it there, and
  // then send it straight up to note heaven with no horizontal motion.
	const transformMatrix = window.getComputedStyle(group).transform;
  // transformMatrix will be something like 'matrix(1, 0, 0, 1, -118, 0)'
  // where, since we're only translating in x, the 4th property will be
  // the current x-translation. You can dive into the gory details of
  // CSS3 transform matrices (along with matrix multiplication) if you want
  // at http://www.useragentman.com/blog/2011/01/07/css3-matrix-transform-for-the-mathematically-challenged/
	const x = transformMatrix.split(',')[4].trim();
	// And, finally, we set the note's style.transform property to send it skyward.
	group.style.transform = `translate(${x}px, -800px)`;
})


</script>



</body>
</html>
